# Portfolio

**Gaming Room**
Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
I worked for Creative Technology Solutions and the client was "The Gaming Room". They wanted our help with bringing their game appliction, Draw it or Lose it, to more web platforms. They were only active on Andriod. 

What did you do particularly well in developing this documentation?
The easiest part for me was the first part where we had to summarise, recognize constraints, and evaluate the UVL diagram. 

What about the process of working through a design document did you find helpful when developing the code?
I think the design document is good for organizing what the project is really about. It provided a wide veiw look at the solution needed. 

If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
I would complete the evaluation of different operating platforms. I found it very difficult to find information for client side vs developer side. I also don't have a great grasp as to all the parts of each platform so I would have to look into that deeper. 

How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
Because I am a gamer myself I knew how important it is to make the game user friendly. If the client is not considered then the application will not be useful. A couple needs that I included were account details like a password. 

How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
I would definitely use the beginning of the document to consider what the client needs and wants. The overview of the constraints and the path of development was very logically useful.

**Artemis Financial**
Briefly summarize your client, Artemis Financial, and their software requirements. Who was the client? What issue did they want you to address?
Artemis Financial is a financial consulting company that wanted to modernize its website and update its security.

What did you do very well when you found your client’s software security vulnerabilities? Why is it important to code securely? What value does software security add to a company’s overall wellbeing?
It is important to secure and fix possible security vulnerabilities to prevent attacks in the future. When the client company is in the financial industry it is especially vital to secure client information. To comply with regulations set in the industry the company must be conscious about fixing any possible vulnerabilities. Good security also helps the company's image in the eyes of the consumer. 

What part of the vulnerability assessment was challenging or helpful to you?
For most of this course, we focused on using cryptography to create secure code. The most difficult part of cryptography for me was understanding what an algorithm cipher was vs a hash function. I still think they are separate coding practices but some wording in the assignments seemed to interchange them. 

How did you increase layers of security? In the future, what would you use to assess vulnerabilities and decide which mitigation techniques to use?
To increase security in the projects we used the hash function SHA-256 and Maven to access vulnerabilities and understand which needed to be looked at closer and which had no known fixes at the time. We also updated the Artemis Financials website from HTTP to HTTPS. This brought better encryption and security using TLS. 

How did you make certain the code and software application were functional and secure? After refactoring the code, how did you check to see whether you introduced new vulnerabilities?
To make certain I did not introduce new vulnerabilities, I simply reran Maven to produce another dependency report. Then checked to see if what I was expecting was there. 

What resources, tools, or coding practices did you use that might be helpful in future assignments or tasks?
I used Java Eclipse to finish these projects. Eclipse enabled me to create certificates and import key tools. If I ever need an additional add-on I know how to import that through Eclipse. I also found it very insightful to use the Windows command prompt for the first time.

Employers sometimes ask for examples of work that you have successfully completed to show your skills, knowledge, and experience. What might you show future employers from this assignment?
I think I would show them that I understand how to check vulnerabilities and dependencies. The Project also shows them I know how to create a cipher key. In Project Two I would like to show them that I know how to generate a certificate. 


**DriverPass**
Briefly summarize the DriverPass project. Who was the client? What type of system did they want you to design?
DriverPass is a startup that is looking to fill the market gap in online driving test practice. They wanted us to design a system where clients to go to take online up-to-date practice tests and schedule driving time with instructors.

What did you do particularly well?
I feel that once I got into it I was able to create some good UML diagrams to describe different functions and activities of the website. 

If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
I think I would like to add more detail to the activity diagrams to account for more possibilities. 

How did you interpret the user’s needs and implement them into your system design? Why is it so important to consider the user’s needs when designing?
The reason that the website is being created is for the users. Both the client's customers and the clients. I tried to think of actions that the user may need to take, for example, resetting a password. 

How do you approach designing software? What techniques or strategies would you use in the future to analyze and design a system?
I like creating the UML diagrams. They provide a quick overview of how the system needs to be designed. They also help prevent forgetting steps. They are also able to be updated as new things develop, making them a versatile tool.

**ContactClass**
To ensure that my code is functional, I created JUnit tests where I attempted to test every action that the code could perform. I tested fail cases and success cases. If the code failed, I had print statements to identify what went wrong and where. I also wanted these print statements to tell the end user important information. If they tried to input a Contact where the first name was too long then I had a statement that let them know that. I tried to approach this design from an end-user standpoint. What would the consumer want to be able to do and where could an error arise? Thinking of these questions helped drive how I made the code. 

**Course 300**
What was the problem you were solving in the projects for this course?
  I was given a company that had a list of interconnected courses. They want to be able to hold these courses in a data structure where they could access one course or view all courses in a schedule.  
  
How did you approach the problem? Consider why data structures are important to understand.
  First, I had to decide what data structure would be best to hold such a list. I decided to choose a binary tree because of their ability to directly connect each object even if their runtime was the longest. 
How did you overcome any roadblocks you encountered while going through the activities or project?

  The biggest roadblock I had was keeping my head wrapped around what I needed to do and how. I spent a lot of time looking at the code that was given to us and trying to understand why each part was important. If I struggled with writing a specific method I would research as much as I could on what I needed to do and how. I learned a lot about how nodes worked and what they could do. If I really became frustrated I made sure to give myself time to step back from the code and come back to it later.
  
How has your work on this project expanded your approach to designing software and developing programs?
  This project helped me learn a lot about binary trees, vectors, and hashtables. Before this project I had no idea what binary trees were, much less how to code one and perform actions on them. In regards to the actual process of developing a solution to a problem I now know the value of pseudo code and creating a baseline for what functions the project needs to have. 
  
How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
Before this project, I didn't think that in-line comments were all that important but now I realize how valuable they are. If I had to step away for a while and came back to no comments then I would have to relearn how my code worked by going line by line. With the inline comments, I knew what steps I had completed and what I needed to do. 

**Course330**
What new design skills has your work on the project helped you to craft?
I think the most impactful design skill that came about in this project is the ability to break down objects into smaller basic shapes. 

What design process did you follow for your project work?
I followed the process laid out in the course. Start by creating the basic shape in the 3D space, add camera movement, add textures, add lighting, and then do that step by step for each object. 

How could tactics from your design approach be applied in future work?
One thing that I would add to my design approach for future work would be to break down each object into its own function instead of having it all under "RenderScene". 

What new development strategies did you use while working on your 3D scene?
To develop this project I had to reference the libraries far more than I have had to in the past. This helped me find functions such as the mouse scroller input.

How did iteration factor into your development?
After I finished creating the first object, the pencil, the others were a breeze. I could repeat and use similar coding techniques for each object.

How has your approach to developing code evolved throughout the milestones, which led you to the project’s completion?
The biggest strategy that I changed was to look at what functions were already provided and how they would help me lead to the solution. 

How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future educational pathway?
If I take another class in computational graphics this class was really useful in getting the basics solidified. 

How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future professional pathway?
I don't believe that I will have to make 3D graphics for my current profession but maybe in the future if I move into something like marketing, I could create simple images to help demonstrate products. 

**Course350**

In this course, I created a project using the CC3220SF development board. The goal of the project was to read the temperature from the board's sensor and perform a couple of operations. The project successfully outputs the content to the terminal. 

Understanding the Task Scheduler was the easy part. Setting up the button and temperature timers was intuitive. I knew that I had to perform actions every time a timer would go off so I made methods to keep it tidy. I did struggle a little with understanding why the temperature timer and the LED timer had to be separate functions. The only thing the temperature method did was set the value of whether heat was on or off. 

I think the main way I could improve is by understanding all the code that was given to us. I had to look into the declaration of one parameter multiple times. 

I had never used any piece of hardware before so it was really useful to learn about how it interacts with software development. If I ever need to use a development board again then I have the basic level of understanding. 

I made the project maintainable by adding comments and separating actions into their methods. 



